# SCRIPT MIKROTIK ON-LOGIN (OPTIMIZED)
# Fungsi: Live Report + Preserve Blok Info + Auto Scheduler
# Update: 2026-01-30

# --- KONFIGURASI ---
:local baseUrl "{{BASE_URL}}";
:local key "{{LIVE_KEY}}";
:local session "{{SESSION}}";
:local usageKey "{{USAGE_KEY}}";

# --- HELPER: URL ENCODE (Compact & Fast) ---
:local urlEncode do={
    :local i [:tostr $1]; :local o ""; :local l [:len $i];
    :if ($l=0) do={:return ""}
    :for c from=0 to=($l-1) do={
        :local ch [:pick $i $c];
        :if ($ch=" ") do={:set o ($o."%20")} else={
        :if ($ch=":") do={:set o ($o."%3A")} else={
        :if ($ch="/") do={:set o ($o."%2F")} else={
        :if ($ch="|") do={:set o ($o."%7C")} else={
        :set o ($o.$ch)}}}}
    }
    :return $o;
};

# --- MAIN LOGIC ---
{
    :local username "$user";
    :local userip "$address";
    :local usermac $"mac-address";
    :local date [/system clock get date];
    :local time [/system clock get time];
    :local year [:pick $date 7 11];
    :local month [:pick $date 0 3];
    
    # 1. AMBIL DATA USER (SAFE METHOD)
    # Menggunakan do-on-error agar script tidak stop jika user dihapus saat proses
    :do {
        :local uID [/ip hotspot user find where name="$username"];
        :local comment "";
        :local profile "";
        
        :if ([:len $uID] > 0) do={
            :set uID ($uID->0);
            :set comment [/ip hotspot user get $uID comment];
            :set profile [/ip hotspot user get $uID profile];
        }
        
        # 2. EKSTRAK INFO "Blok-" (METODE CEPAT :FIND)
        # Tidak menggunakan looping karakter yang berat
        :local blokInfo "";
        :local posBlok [:find $comment "Blok-"];
        if ([:typeof $posBlok] = "nil") do={ :set posBlok [:find $comment "blok-"]; }
        
        :if ([:typeof $posBlok] != "nil") do={
            :local endPos [:find $comment "|" $posBlok];
            :if ([:typeof $endPos] = "nil") do={ :set endPos [:len $comment]; }
            :set blokInfo [:pick $comment $posBlok $endPos];
            
            # Bersihkan spasi di ujung (Trim)
            :if ([:pick $blokInfo ([:len $blokInfo]-1)] = " ") do={
                :set blokInfo [:pick $blokInfo 0 ([:len $blokInfo]-1)];
            }
        }

        # 3. LOGIC SCHEDULER & LOGGING (MIKHMON STYLE)
        # Cek apakah log hari ini sudah ada
        :local hasLog [/system script find where comment="mikhmon" and name~"-\\|-$username-\\|-"];
        
        :if ([:len $hasLog] = 0) do={
            # Buat Scheduler Baru (Untuk hitung expired)
            :do {
                /sys sch add name="$username" disable=no start-date=$date interval="1d";
            } on-error={ :log debug "LOGIN: Scheduler exist, skip."; }
            
            :delay 2s;
            
            # Ambil Expired Date dari Scheduler
            :local schId [/sys sch find where name="$username"];
            :local exp "";
            :if ([:len $schId] > 0) do={
                :set exp [/sys sch get ($schId->0) next-run];
                # Hapus scheduler temp (PENTING: Agar tidak menumpuk)
                /sys sch remove $schId;
            }

            # Format Komentar Baru
            :local newComment "";
            
            # Cek tanggal lama di comment (Prioritas)
            :local pipePos [:find $comment "|"];
            :if ([:typeof $pipePos] != "nil") do={
                :set newComment [:pick $comment 0 $pipePos];
            } else={
                # Jika kosong, pakai expired dari scheduler atau waktu sekarang
                :local getxp [:len $exp];
                :if ($getxp = 15) do={ :set newComment ([:pick $exp 0 6]."/".$year." ".[:pick $exp 7 16]); }
                :if ($getxp = 8) do={ :set newComment ("$date $exp"); }
                :if ([:len $newComment] = 0) do={ :set newComment "$date $time"; }
            }
            
            # Gabungkan: TANGGAL | BLOK INFO
            :if ([:len $blokInfo] > 0) do={ :set newComment ("$newComment | $blokInfo"); }
            
            # 4. SIMPAN LOG DATABASE (SYSTEM SCRIPT)
            :local price "5000"; :local validity "1d"; :local pLabel "10Menit";
            :if ($profile = "30Menit") do={ :set price "20000"; :set pLabel "30Menit"; }
            
            :local logTxt "$date-|$time-|$username-|$price-|$userip-|$usermac-|$validity-|$pLabel-|$blokInfo";
            
            :do {
                /system script add name=$logTxt owner="$month$year" source="$date" comment="mikhmon";
            } on-error={ :log warning "LOGIN: Gagal simpan DB lokal"; }

            # 5. FETCH LIVE INGEST (HTTP POST)
            :if ([:len $baseUrl] > 0 && [:find $baseUrl "{{"] = nil) do={
                :local liveUrl ($baseUrl . "/report/laporan/services/live_ingest.php");
                :local postData ("data=".[$urlEncode $logTxt]."&key=".[$urlEncode $key]."&session=".[$urlEncode $session]);
                :do { 
                    /tool fetch url=$liveUrl http-method=post http-data=$postData keep-result=no; 
                } on-error={ :log debug "LOGIN: Live ingest timeout"; }
            }

            # 6. UPDATE USER COMMENT
            :if ([:len $uID] > 0) do={
                :do { /ip hotspot user set comment=$newComment mac-address=$usermac $uID; } on-error={}
            }
        }

        # 7. FETCH USAGE (Login Event)
        :if ([:len $baseUrl] > 0 && [:find $baseUrl "{{"] = nil) do={
            :local useUrl ($baseUrl."/report/laporan/services/usage_ingest.php?key=".[$urlEncode $usageKey]."&session=".[$urlEncode $session]."&event=login&user=".[$urlEncode $username]."&date=".[$urlEncode $date]."&time=".[$urlEncode $time]."&ip=".[$urlEncode $userip]."&mac=".[$urlEncode $usermac]."&uptime=0s");
            :do { /tool fetch url=$useUrl keep-result=no; } on-error={}
        }
    } on-error={ :log error "LOGIN CRITICAL ERROR for $username"; }
}